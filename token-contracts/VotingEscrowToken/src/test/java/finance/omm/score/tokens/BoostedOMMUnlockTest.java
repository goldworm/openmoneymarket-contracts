/*
 * Copyright (c) 2021 Balanced.network.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package finance.omm.score.tokens;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.spy;

import com.iconloop.score.test.Account;
import com.iconloop.score.test.Score;
import com.iconloop.score.test.ServiceManager;
import com.iconloop.score.test.TestBase;
import finance.omm.libs.address.Contracts;
import finance.omm.libs.test.VarargAnyMatcher;
import finance.omm.score.tokens.utils.IRC2Token;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Stream;
import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.mockito.ArgumentMatchers;


public class BoostedOMMUnlockTest extends TestBase {

    private static final ServiceManager sm = getServiceManager();
    private static final Account owner = sm.createAccount();
    private Score veOMMScore;
    private Score tokenScore;

    private BoostedOMM scoreSpy;

    private Account addressProvider = Account.newScoreAccount(1001);

    public static BigInteger WEEK = BigInteger.TEN.pow(6)
            .multiply(BigInteger.valueOf(86400L).multiply(BigInteger.valueOf(7L)));
    private static final BigInteger INITIAL_SUPPLY = BigInteger.TEN.multiply(ICX);
    private static final String BOOSTED_OMM = "Boosted Omm";
    private static final String B_OMM_SYMBOL = "veOMM";


    @BeforeEach
    public void setup() throws Exception {
        tokenScore = sm.deploy(owner, IRC2Token.class, INITIAL_SUPPLY);
        veOMMScore = sm.deploy(owner, BoostedOMM.class, addressProvider.getAddress(), tokenScore.getAddress(),
                BOOSTED_OMM, B_OMM_SYMBOL);
        scoreSpy = (BoostedOMM) spy(veOMMScore.getInstance());
        veOMMScore.setInstance(scoreSpy);

        VarargAnyMatcher<Object> matcher = new VarargAnyMatcher<>();
        doNothing().when(scoreSpy)
                .scoreCall(eq(Contracts.DELEGATION), eq("updateDelegations"),
                        ArgumentMatchers.<Object>argThat(matcher));
        doNothing().when(scoreSpy)
                .scoreCall(eq(Contracts.REWARDS), eq("handleAction"), ArgumentMatchers.<Object>argThat(matcher));

    }

    @ParameterizedTest
    @MethodSource("weekListLock")
    public void testCreateLockZeroBalance(long unlockTime) {

        long timestamp = sm.getBlock().getTimestamp();
        long expectedUnlock = unlockTime + timestamp;

        Map<String, Object> map = new HashMap<>();
        map.put("method", "createLock");
        map.put("params", Map.of("unlockTime", expectedUnlock));
        JSONObject json = new JSONObject(map);
        byte[] lockBytes = json.toString().getBytes();
        tokenScore.invoke(owner, "transfer", veOMMScore.getAddress(), ICX.multiply(BigInteger.ONE), lockBytes);

        Map<String, BigInteger> balance = (Map<String, BigInteger>) veOMMScore.call("getLocked", owner.getAddress());
        long actual_unlock = balance.get("end").longValue();
        long delta = BigInteger.valueOf(actual_unlock - timestamp).divide(BigInteger.TEN.pow(6)).divide(BigInteger.TWO).longValue();

        sm.getBlock().increase(delta - 5);
        BigInteger _balance = (BigInteger) veOMMScore.call("balanceOf", owner.getAddress(), BigInteger.ZERO);
        assertTrue(_balance.compareTo(BigInteger.ZERO) > 0);

        sm.getBlock().increase(6);

        _balance = (BigInteger) veOMMScore.call("balanceOf", owner.getAddress(), BigInteger.ZERO);
        assertEquals(_balance, BigInteger.ZERO);
    }

    @ParameterizedTest
    @MethodSource("extendedUnlockWeeks")
    public void testIncreaseLockZeroBalance(long unlockTime, long extendedTime) {

        long timestamp = sm.getBlock().getTimestamp();
        long expectedUnlock = unlockTime + timestamp;

        Map<String, Object> map = new HashMap<>();
        map.put("method", "createLock");
        map.put("params", Map.of("unlockTime", expectedUnlock));
        JSONObject json = new JSONObject(map);
        byte[] lockBytes = json.toString().getBytes();

        tokenScore.invoke(owner, "transfer", veOMMScore.getAddress(), ICX.multiply(BigInteger.ONE), lockBytes);

        Map<String, BigInteger> balance = (Map<String, BigInteger>) veOMMScore.call("getLocked", owner.getAddress());
        BigInteger initialUnlock = balance.get("end");
        BigInteger expectedExtendedUnlockTime = initialUnlock.add(BigInteger.valueOf(extendedTime));

        veOMMScore.invoke(owner, "increaseUnlockTime", expectedExtendedUnlockTime);

        Map<String, BigInteger> newBalance = (Map<String, BigInteger>) veOMMScore.call("getLocked", owner.getAddress());
        BigInteger extendedActualUnlock = newBalance.get("end");

        long delta = extendedActualUnlock.subtract(BigInteger.valueOf(timestamp)).divide(BigInteger.TEN.pow(6)).divide(BigInteger.TWO).longValue();

        sm.getBlock().increase(delta - 2);
        BigInteger _balance = (BigInteger) veOMMScore.call("balanceOf", owner.getAddress(), BigInteger.ZERO);
        assertTrue(_balance.compareTo(BigInteger.ZERO) > 0);

        sm.getBlock().increase(3);

        _balance = (BigInteger) veOMMScore.call("balanceOf", owner.getAddress(), BigInteger.ZERO);
        assertEquals(_balance, BigInteger.ZERO);
    }


    private static Stream<Arguments> weekListLock() {

        long low = WEEK.longValue() * 2;
        long high = WEEK.longValue() * 52;
        return Stream.of(Arguments.of(ThreadLocalRandom.current().nextLong(low, high + 1)), Arguments.of(ThreadLocalRandom.current().nextLong(low, high + 1)), Arguments.of(ThreadLocalRandom.current().nextLong(low, high + 1)));
    }

    private static Stream<Arguments> extendedUnlockWeeks() {

        long week = WEEK.longValue();
        long low = week * 2;
        long high = week * 52;
        return Stream.of(Arguments.of(ThreadLocalRandom.current().nextLong(low, high + 1), ThreadLocalRandom.current().nextLong(week, low)), Arguments.of(ThreadLocalRandom.current().nextLong(low, high + 1), ThreadLocalRandom.current().nextLong(week, low)), Arguments.of(ThreadLocalRandom.current().nextLong(low, high + 1), ThreadLocalRandom.current().nextLong(week, low)));
    }
}
